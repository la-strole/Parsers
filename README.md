
## Parsers
### Цель проекта:
Парсинг сайтов для автоматизации существующей сводной таблицы в libreoffice calc (libreoffice calc файл).  
Планирую использовать авито для мониторинга изменения цены недвижимости в Пскове.  
Все парсеры можно использовать независимо от libreoffice calc файла.
### Требования
1. ОС Linux 64 (тестировался на Debian 10, Ubuntu 20.04.3);
2. python версии выше 3.5;
3. Установленный python3-venv для создания виртуальной среды;
4. Firefox версии выше 48 (для работы с сайтом московской фондовой биржи);
5. Подключение к Интернет (для скачивания библиотек python);  

либо установленный docker engine.

### Текущее использование следующее:
Запустить bash скрипт start_parsers.sh, который активирует `venv` и запускает `main.py`, который создает набор файлов `*csv`, которые, в свою очередь подгружаются как external data в **существующий файл libreoffice calc**, где есть наборы формул, графиков итп для аналитики и планирования.

### Собирает следующие данные:
1. `avito_flat.py` (https://avito.ru) - стомость однокомнатных квартир по адресу г. Псков, Крестки 3А;
2. `gold_price.py` (https://bankinform.ru) - максимальная стоимость покупки грамма золота 999 пробы;
3. `moex_bonds.py` (https://moex.com) - стоимость в процентах к номиналу облигаций XS0893212398 и XS0088543193 на московской фондовой бирже;
4. `pskov_banki_ru_currency.py` (https://www.banki.ru) - наиболее выгодгые курсы обмена USD и EUR в банках Пскова;
5. `uralsib_coins.py` (https://www.uralsib.ru) - стоимость монеты Георгий победоносец номиналом 100 в банке Уралсиб;
6. `main.py` - объединяет все вместе.
### Запуск из docker образа:
Запустите в интерактивном режиме `docker run -it eugeneparkhom/20ty9jwo`  
(https://hub.docker.com/repository/docker/eugeneparkhom/20ty9jwo)
#### Резульат работы docker контейнера:
Результат работы парсеров в консоли.

### Запуск локально с помощью скрипта:
Все зависимости, библиотеки, файлы будут находятся в рабочем каталоге.
#### Создание окружения:
1. Клонировать репозиторий в предполагаемый рабочий каталог;
1. Запустить скрипт `create_environment.sh`.

  ##### create_environment.sh:
  1. Определит рабочий каталог как текущий (для изменения поведения отредактируйте переменную `path_line`);
  2. Создаст в рабочем каталоге виртуальную среду для python `parsers_venv`;
  3. Скачает в эту среду библиотеки для зависимостей python, перечисленные в файле `requirements.txt`;
  4. Скачает и распакует `geckodriver` Firefox в рабочий каталог.

#### Запуск:
Запуск **всех** парсеров по очереди:
1. Запустить `start_parsers.sh`.<br/>
    По умолчанию все `*csv` после работы парсеров сохранятся в рабочем каталоге. Путь можно поменять изменив параметр `-path` в строке `python "$path_line/main.py" -path "$path_line/" &>> "$path_line/log.txt"` скрипта `start_parsers.sh`;
2. Логи пишутся в `log.txt` в рабочем каталоге.<br/>

Запуск парсеров по отдельности:
1. Перейти в созданную virtual environment (`$ source parsers_venv/bin/activate`);  
2. Запустить нужный парсер с обязательным аргументом командной строки `-path`  
	(`(parsers_venv)$ python <name_of_parser>.py -path path/to/working/dir/`);
4. Парсер сохранит `*csv` по заданному `-path`пути;  
5. **Внимание:** При запуске `moex_bonds.py` необходимо обратить внимание на то, что для корректной работы selenium необходимо, чтобы geckodriver находился в каталоге `-path` либо путь к нему находился в PATH ОС.


#### Результат работы start_parsers.sh:
В рабочем каталоге создаются файлы:
1. `for_open_office0.csv`<br/>
*[стоимость_портфеля, timestamp]*<br/>
При каждом запуске дописываем строку со стоимостью портфеля из libreoffice calc файла.
Необходим для постоения графика изменеия цены портфеля. Если нет файла libreoffice calc - не создается (ошибка пишется в `log.txt`).
2. `for_open_office1.csv`<br/>
*[количество_квартир, количество_цен]*<br/>
*[Продана_ли(True/False), идентификатор(кол-во комнат площадь, этаж), стоимость1, стоимость2,...]*</br>
Количество квартир, количество цен - необходимо для работы макроса в файле libreoffice calc - расичтываем среднюю цену квартир на последний день), остальные строки для графика изменения стоимости квартир.
3. `for_open_office2.csv`<br/>
*[текущая стоимость в проценах от номинала облигации XS0893212398]*<br/>
*[текущая стоимость в проценах от номинала облигации XS0088543193]*<br/>
4. `for_open_office3.csv`<br/>
*[лучшая цена покупки грамма золота, название банка, timestamp]*
6. `for_open_office4.csv`<br/>
*[стоимость монеты Георгий победоносец 100 в банке Уралсиб]*
8. `for_open_office5.csv`<br/>
*[лучшая цена покупки USD, название банка, timestamp]*<br/>
*[лучшая цена покупки EUR, название банка, timestamp]*<br/>
*[лучшая цена продажи USD, название банка, timestamp]*<br/>
*[лучшая цена продажи EUR, название банка, timestamp]*<br/>
*[курс ЦБРФ USD, CBRF, timestamp]*<br/>
*[курс ЦБРФ EUR, CBRF, timestamp]*<br/>

#### Результат работы отдельных парсеров:
1. `avito_flat.py`:<br/>
  файл `avito_flat_prices.csv` с структурой:<br/>
  *[количество_квартир, количество_цен]*<br/>
  *[Продана_ли(True/False), идентификатор(кол-во комнат площадь, этаж), стоимость1, стоимость2,...]*</br>
2. `gold_price.py`<br/>
  файл `best_gold_price.csv` с структурой:<br/>
  *[лучшая цена покупки грамма золота, название банка, timestamp]*
3. `moex_bonds.py`<br/>
  файл `moex_bonds.csv` с структурой:<br/>
  *[текущая стоимость в проценах от номинала облигации XS0893212398]*<br/>
  *[текущая стоимость в проценах от номинала облигации XS0088543193]*<br/>
4. `pskov_banki_ru_currency.py`<br/>
  файл `pskov_bank_currency.csv` с структурой:<br/>
  *[лучшая цена покупки USD, название банка, timestamp]*<br/>
  *[лучшая цена покупки EUR, название банка, timestamp]*<br/>
  *[лучшая цена продажи USD, название банка, timestamp]*<br/>
  *[лучшая цена продажи EUR, название банка, timestamp]*<br/>
  *[курс ЦБРФ USD, CBRF, timestamp]*<br/>
  *[курс ЦБРФ EUR, CBRF, timestamp]*<br/>
5. `uralsib_coins.py`<br/>
  файл `uralsib_coin_price.csv` с структурой:<br/>
  *[стоимость монеты Георгий победоносец 100 в банке Уралсиб]*

#### Использованы библиотеки:
1. requests;
2. BeautifulSoup;
3. selenium - для парсига московской фондовой биржи (https://moex.com) (необходимо нажать кнопку согласия, данные формируюся JS и обновляются раз в 5 секунд).


### Подробнее про парсер avito:

1. `avito_plat.py` - 	скрипт для парсинга сайта https://avito.com на предмет изменения статуса (цена, описание, наличие) однокомнатных квартир в доме по адресу Псков, Крестки 3А. (задается в строчке url как параметры get запроса);
2. #### Зависимости:

- requests 2.26.0
- bs4.BeautifulSoup 4.10.0
- lxml 4.6.3
3. #### Входные данные:

- страница авито по ссылке в переменной url;
- файл `avito_flat_kres.json` (в каталоге со скриптом - создается при первом запуске, если хотите изменить путь - измените `path_to_json_file`);
4. #### Выходные данные:

- модифицированный (или созданный файл `avito_flat_kres.json` с дампом квартир);
- файл `avito_flat_kres.csv` в папке со скриптом (для изменения пути измените `path_to_csv_file`);
5. #### Логика работы:

	1. Скачиваем страницу с авито с помощью `requests`. `avito.ru/robots.txt` не запрещает парсить эти разделы. Использовал `headers` из браузера. Полагаю необязательным, но с ними протестировано и 			работает;
	2. Парсим ее с помощью `BeautifulSoup` и `lxml`. Стараемся найти более-менее постоянные блоки по логике и типу `css class, data-marker` итп;
	3. Создаем множество квартир с авито `avito_flats_set:set` (далее множество `А`) из объектов класса `flat`;
	**важное замечание!**
	*Так как квартиры могут продаваться разными людьми, с разными `avito_id`, по разной цене, то фактически невозможно без допущений их сравнивать. Тут принято допущение (переписыванием 			`flat.__eq__()` и `flat.__hash__()`, что если квартиры имеют одну **площадь** и один **этаж** - они **одинаковы**.*
	4. Создаем список объектов класса `flat`, уже известных нам (далее - множество `Ф`)-`file_flat_set:list` - считываем `json dump` из `avito_flat_krest.json` либо (если файла нет) инициируем пустым	списком;
	5. Помечаем возможно проданными квартиры (функцией `set_maybe_sold()`) из *разности* множеств `Ф - А` (есть в известных нам - пропали с авито);
	6. Обновляем описание, цену, `avito_id`, `timestamps` для *пересечения* множеств `А и Ф` (известны нам и в продаже);
	7. Добавляем в известные нам квартиры (множество `Ф`) разницу `А - Ф`. (появившиеся на авито);
	8. Формируем `json` дамп вида `[falt_instance1.__dict__, flat_instance2.__dict__]` множества `Ф` и сохраняем его перезаписывая/создавая `avito_flat_kres.json`;
	9. Добавляем в конец файла `avito_flat_kres.csv` `(id, price, timestams)` для последующего использования в БД (сейчас закоментировано).
	10. Создаем файл `for_open_office1.csv` где каждая строка - квартира из файла `avito_flat_krest.json`. Обновленную стоимость дописываем последней в строку, Если квартира продана, первым элементом csv файла будет `True`, иначе `False`.

6. #### Структура данных:
`class flat`:
- `id: int` - уникален. Генерируем автоматически при создании экземпляра класса. Возможно, будет потом `private key` в базе данных;
- `room_count: int` - Число комнат. Здесь для всех одинаковый (пока интересуют только 1 комнатные);
-  `flat_area: float` - Площадь квартиры. Первый из атрибутов для определения эквивалентности квартир;
- `floor: int` - Этаж квартиры. Второй элемент для определения эквивалентности квартир;
- `total_floors: int` - Общее количество этажей в доме. Здесь дом единственный, этажей 10;
- `address: str` - Адрес. Здесь везде одинаковый (ул. Крестки, 3А);
- `development_name` - название ЖК. Здесь везде одинаковый;
- `district: str` - район города с маленькой буквы, здесь везде `'завеличье'`;
- `description[[description_string: str, timestamp: isoformat],]` - добавляем в список описание с `timestamp`, если оно изменилось на авито. Здесь и далее используем список списков *для легкой	сериализации в `json` файл*;
- `avito_id[[avito_id_value:str, timestamp:isoformat],]` - добавляем при каждом запуске, интересно последить за изменениями `avito_id`;
- `price[[value:int, timestamp:isoformat],]` - добавляем при каждом запуске для формирования `csv` файла и графиков в libreoffice по динамике цены;
- `maybe_sold: bool` - `False` по умолчанию. Меняем на `True` при исчезновении объявления на авито. При этом соответствующий дамп словаря экземпляра класса все равно хранится в `avito_flat_kres.json`	(но `timestamp` не обновляем) и при появлении на авито этой же квартиры снова - меняем `maybe_sold` на `False`. Таким образом пытаюсь отслеживать квартиры при их кратковременном исчезновении на авито - например, по окончанию срока объявления, когда его перевыкладывают (возможно другие риелторы с другим `avito_id`) считаю это возвращением уже известной мне квартиры. До этого времени экземпляры с `maybe_sold == True` позволяют знать последнюю стоимость по которой она (возможно) была продана.

7. #### Сложности и планы:
	1. `avito_flat_set = set()`, `file_flat_set = list()`. Изначально оба были `set`. Хотелось использовать возможности `set` для быстрых операций над множествами - без `list comprehension` итп. Но столкнулся с неопределенностью поведения при пересечении множеств - по допущению экземпляры эквивалентны при совпадении `flat.area` и `flat.floor` - но их `price, description, avito_id` могут отличаться. Мне же критично получить свежие данные с авито, но не заменить ими имеющиеся в файле, а добавить свежие данные c `timestamps` в списки `flat.price`, `flat.description` и `flat.avito_id`. Объекты же множества `file_flat_set` с применением методов класса `set` (`intersection update` итп) вели себя неопределенно. Решением (скорее всего временным) стало использование `set` для данныхс авито, и `list` для данных из файла. На таком небольшом объеме это не привело к заметному уменьшению производительности, но, конечно это рещение далеко от идеала и, скорее всего, будет	исправлено. Частичным решением проблемы поиска пересечений двух множеств, где элементы не полностью эквивалентны стало применение "черновых" списков `update_set_flat` и `update_set_avito`. Решение это явно не оптимальное и также будет переработано. Возможно, наблюдения за измениями `avito_id` позволят решить проблему определения эквивалентности объектов	класса `flat`.
	2. Также не очень удобно было передавать `json.load` в конструктор класса. Использовал единственный аргумент - словарь и в конструкторе прямой доступ к словарю `self.__dict__`. Для защиты атрибутов от случайных изменеий перед прямым доступом к словарю проверяем ключи на наличие их в `allowed_args` - словаре (переменной класса `flat`) с допустимыми ключами.
