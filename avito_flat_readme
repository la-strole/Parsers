1. avito_plat.py - скрипт для парсинга сайта avito.com на предмет изменения статуса (цена, описание, наличие) однокомнатных квартир в доме по адресу Псков, Крестки 3А. (задается в строчке url как параметры get запроса)
2. Зависимости: модули 
- requests 2.26.0
- bs4.BeautifulSoup 4.10.0
- lxml 4.6.3
3. Входные данные:
- страница авито по ссылке в переменной url
- файл avito_flat_kres.json (в каталоге со скриптом - создается при первом запуске, если хотите изменить путь - измените path_to_json_file)
4. Выходные данные:
- модифицированный (или созданный файл avito_flat_kres.json с дампом квартир)
- файл avito_flat_kres.csv в папке со скриптом (для изменения пути измените path_to_csv_file)
5. Логика работы:
1. Скачиваем страницу с авито с помощью requests. avito.ru/robots.txt не запрещает парсить эти разделы. использовал headers из браузера. Полагаю необязательным, но с ними протестировано и работает.
2. Парсим ее с помощью BeautifulSoup и lxml.  Стараемся найти более-менее постоянные блоки по логике и типу css class, data-marker итп.
3. Создаем множество квартир с авито avito_flats_set:set (далее множество А)из объектов класса flat
важное замечание! 
Так как квартиры могут продаваться разными людьми, с разными avito_id, по разной цене, то фактически невозможно без допущений их сравнивать. Тут принято допущение (переписыванием flat.__eq__() и flat.__hash__(), что если квартиры имеют одну площадь и один этаж - они одинаковы.
4. Создаем список объектов класса flat, уже известных нам (далее - множество Ф)- file_flat_set:list - считываем json dump из avito_flat_kres.json либо (если файла нет) инициируем пустым списком.
5. Помечаем возможно проданными квартиры (функцией set_maybe_sold()) из разности множеств Ф - А (есть в известных нам - пропали с авито)
6. Обновляем описание, цену, avito_id, timestamps для пересечения множеств А и Ф (известны нам и в продаже)
7. Добавляем в известные нам квартиры (множество Ф) разницу А - Ф. (появившиеся на авито)
8. формируем json дамп вида [falt_instance1.__dict__, flat_instance2.__dict__] множества Ф и сохраняем его перезаписывая/создавая avito_flat_kres.json
9. добавляем в конец файла vito_flat_kres.csv (id, price, timestams) для добавления в имеющийся у меня файл excel.

структура данных 
class flat:
	id:int - уникален. генерируем автоматически при создании экземпляра класса. Возможно, 			 будет потом private key в базе данных
	room_count: int - тут для всех одинаковый
	flat_area:float - один из атрибутов для определения эквивалентности квартир
	floor:int - второй элемент для определения эквивалентности квартир
	total_floors:int
	address: str - тут везде одинаковый
	development_name - название ЖК. Тут везде одинаковый
	district:str - район города с маленькой буквы тут везде 'завеличье'
	description[[description_string:str, timestamp:isoformat],] - добавляем в список 				описание с timestamp, если оно изменилось на авито. Здесь и далее используем список списков для легкой сериализации в json файл.
	avito_id[[avito_id_value:str, timestamp:isoformat],] - добавляем при каждом запуске, интересно последить за изменениями avito_id
	price[[value:int, timestamp:isoformat],] - добавляем при каждом запуске для формирования csv файла и графиков в excel по динамике цены
	maybe_sold: bool - False по умолчанию. Меняем на True при исчезновении объявления на авито. При этом соответствующий дамп словаря экземпляра класса все равно хранится в avito_flat_kres.json (но timestamp не обновляем) и при появлении на авито этой же квартиры снова - меняем maybe_sold на False. Таким образом пытаюсь отслеживать квартиры при их кратковременном исчезновении на авито - например, по окончанию срока объявления, когда его перевыкладывают (возможно другие риелторы с другим avito_id) считаю это возвращением уже известной мне квартиры. До этого времени экземпляры с maybe_sold == True позволяют знать последнюю стоимость по которой она (возможно) была продана.
	
сложности:
avito_flat_set = set(), file_flat_set = list(). Изначально оба были set. Хотелось использоват ьвозможности set для быстрых операций над множествами - без list comprehension итп. Но столкнулся с неопределенностью поведения при пересечении множеств - по допущению экземпляры эквивалентны при совпадении flat.area и flat.floor - но из price, description, avito_id могут отличаться. Мне же критично получить свежие данные с авито, но не заменить ими имеющиеся в файле, а добавить свежие данные c timestamps в списки flat.price, flat.description и flat.avito_id.
объекты же множества file_flat_set с применением методов класса set (intersection upfate итп) вели себя неопределенно. Решением (скорее всего временным) стало использование set для данных с авито, и list для данных из файла. На таком небольшом объеме это не привело к заметному уменьшению производительности, но, конечно это рещение далеко от идеала и, скорее всего будет исправлено. Частичным решением проблемы поиска пересечений двух множеств, где элементы не полностью эквивалентны стало применение "черновых" списков update_set_flat и update_set_avito. Решение это явно не оптимальное и также будет переработано. Возможно, наблюдения за измениями avito_id позволят решить проблему определения эквивалентности объектов класса flat.
Также не очень удобно было передавать json.load в конструктор класса. использовал единственный аргумент - словарь и в конструкторе прямой доступ к словарю self.__dict__. чтобы как-то защитить атрибуты перед прямым боступом к словарю проверяем ключи на наличие их в allowed_args - словаре (переменной класса flat) с допустимыми ключами. 

Замечания по тестированию - использовал assert на типы данных где только можно, защитил открытие файла через try - except FileNotFoundError, ввиду незначительного объема принято решение не писать отдельно функции на доступ к атрибутам объекта класса (обращаемся к ним напрямую) а еще, так как используем прямой доступ к словарю то периодически в "узких" местах проверяем структуру атрибутов класса flat (типы данных, количество значений в списках) функцией flat.control_dict().
	
